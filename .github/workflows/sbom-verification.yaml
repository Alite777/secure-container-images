name: sbom-verification
on:
  pull_request:
    paths:
      - 'cd/helm-charts/**' # Only run on changes to helm charts
  # Allows manual triggering and disablement of workflow
  workflow_dispatch:

permissions:
  contents: read
  packages: read
  security-events: write # Allow uploading SARIF results

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      # declare variables "charts" and "has-charts" to reference them later
      # steps.get-charts references the set id of the first step "Get changed charts"
      charts: ${{ steps.get-charts.outputs.charts }}
      has-charts: ${{ steps.get-charts.outputs.has-charts }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history to compare changes

      - name: Get changed charts
        id: get-charts
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # For manual runs, scan all charts
            CHARTS=$(find cd/helm-charts -maxdepth 1 -mindepth 1 -type d -exec basename {} \; | jq -R -s -c 'split("\n") | map(select(length > 0))')
          else
            # For PRs, only scan changed charts
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
            CHARTS=$(echo "$CHANGED_FILES" | grep '^cd/helm-charts/' | cut -d'/' -f3 | sort -u | jq -R -s -c 'split("\n") | map(select(length > 0))')
          fi
          
          echo "charts=${CHARTS}" >> $GITHUB_OUTPUT
          
          # Check if we have any charts to scan
          if [ "$CHARTS" = "[]" ] || [ -z "$CHARTS" ]; then
            echo "has-charts=false" >> $GITHUB_OUTPUT
            echo "No charts to scan"
          else
            echo "has-charts=true" >> $GITHUB_OUTPUT
            echo "Charts to scan: ${CHARTS}"
          fi

  verification:
    needs: detect-changes
    if: needs.detect-changes.outputs.has-charts == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        chart: ${{ fromJson(needs.detect-changes.outputs.charts) }}
      fail-fast: false # Continue scanning other charts even if one fails

    steps:
      - uses: actions/checkout@v4 # Clones the repository of the workflow into the filesystem of the runner (to ./)

      - name: Install yq
        uses: frenck/action-setup-yq@v1 # Installs yq, a tool that can read yaml files
      
      - name: Login to GHCR for private images
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Read image from values.yaml
        id: image
        run: |
          VALUES_FILE="cd/helm-charts/${{ matrix.chart }}/values.yaml"
          REGISTRY=$(yq e '.image.registry' "$VALUES_FILE")
          REPO=$(yq e '.image.repository' "$VALUES_FILE")
          TAG=$(yq e '.image.tag' "$VALUES_FILE")
          SHA=$(yq e '.image.sha' "$VALUES_FILE")
          DIGEST=$(yq e '.image.digest' "$VALUES_FILE")
          
          # Fallback to 'latest' if tag, sha and digest are all empty
          if ([ -z "$TAG" ] || [ "$TAG" = "null" ]) && ([ -z "$SHA" ] || [ "$SHA" = "null" ]) && ([ -z "$DIGEST" ] || [ "$DIGEST" = "null" ]); then
            TAG="latest"
          fi
          
          # Build full image reference with registry if present
          if [ -n "$REGISTRY" ] && [ "$REGISTRY" != "null" ]; then
            IMAGE="${REGISTRY}/${REPO}:${TAG}"
          else
            IMAGE="${REPO}:${TAG}"
          fi
          
          # Add SHA or digest if present
          if [ -n "$SHA" ] && [ "$SHA" != "null" ]; then
            IMAGE="${IMAGE}@sha256:${SHA}"
          elif [ -n "$DIGEST" ] && [ "$DIGEST" != "null" ]; then
            # If digest already contains sha256:, use as-is, otherwise add prefix
            if [[ "$DIGEST" == sha256:* ]]; then
              IMAGE="${IMAGE}@${DIGEST}"
            else
              IMAGE="${IMAGE}@sha256:${DIGEST}"
            fi
          fi
          
          echo "image=${IMAGE}" >> $GITHUB_OUTPUT
          echo "Scanning image: ${IMAGE}"

      - name: Install cosign
        uses: sigstore/cosign-installer@v4.0.0

      - name: Verify cosign installation
        run: |
          cosign version

      - name: Verify SBOM Signature
        id: verify-sbom
        continue-on-error: true
        run: |
          IMAGE="${{ steps.image.outputs.image }}"
          TRUST_FILE=".github/cosign-trust.yaml"
          echo "Verifying SBOM signature for image: ${IMAGE}"

          if [ ! -f "$TRUST_FILE" ]; then
            echo "Trust config not found: ${TRUST_FILE}"
            echo "verified=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          mapfile -t ISSUERS < <(yq e '.trusted.oidc_issuers[]' "$TRUST_FILE")
          mapfile -t IDENTITIES < <(yq e '.trusted.identities[]' "$TRUST_FILE")

          if [ "${#ISSUERS[@]}" -eq 0 ] || [ "${#IDENTITIES[@]}" -eq 0 ]; then
            echo "No trusted issuers or identities configured in ${TRUST_FILE}"
            echo "verified=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          VERIFIED=false
          MATCHED_ISSUER=""
          MATCHED_IDENTITY=""
          LAST_ERROR=""

          for issuer in "${ISSUERS[@]}"; do
            for identity in "${IDENTITIES[@]}"; do
              echo "Trying issuer: ${issuer}"
              echo "Trying identity: ${identity}"

              if cosign verify-attestation --type=spdxjson --output json --certificate-oidc-issuer="${issuer}" --certificate-identity="${identity}" "${IMAGE}" > /tmp/cosign-attestation.json 2> /tmp/cosign-attestation.err; then
                VERIFIED=true
                MATCHED_ISSUER="${issuer}"
                MATCHED_IDENTITY="${identity}"
                break 2
              else
                LAST_ERROR=$(cat /tmp/cosign-attestation.err)
              fi
            done
          done

          if [ "$VERIFIED" = "true" ]; then
            echo "SBOM Signature verified with Sigstore keyless signing"
            echo "matched-issuer=${MATCHED_ISSUER}" >> $GITHUB_OUTPUT
            echo "matched-identity=${MATCHED_IDENTITY}" >> $GITHUB_OUTPUT
            echo "verified=true" >> $GITHUB_OUTPUT

            jq -s -r '.[0].payload' /tmp/cosign-attestation.json | base64 -d | jq . > sbom-${{ matrix.chart }}.spdx.json
            echo "sbom-file=sbom-${{ matrix.chart }}.spdx.json" >> $GITHUB_OUTPUT
            
            # Extract trivy version from SBOM
            TRIVY_VERSION=$(jq -r '.predicate.creationInfo.creators[] | select(startswith("Tool: trivy-")) | sub("Tool: trivy-"; "")' sbom-${{ matrix.chart }}.spdx.json)
            echo "trivy-version=${TRIVY_VERSION}" >> $GITHUB_OUTPUT
            echo "Detected Trivy version from SBOM: ${TRIVY_VERSION}"
          else
            echo "SBOM Signature verification failed for all trusted issuers/identities"
            if [ -n "$LAST_ERROR" ]; then
              echo "Last error: $LAST_ERROR"
            fi
            echo "verified=false" >> $GITHUB_OUTPUT
          fi

      - name: Install matching Trivy version
        if: steps.verify-sbom.outputs.verified == 'true'
        run: |
          TRIVY_VERSION="${{ steps.verify-sbom.outputs.trivy-version }}"
          echo "Installing Trivy version ${TRIVY_VERSION} to match SBOM generation"
          
          wget -qO /tmp/trivy.deb "https://github.com/aquasecurity/trivy/releases/download/v${TRIVY_VERSION}/trivy_${TRIVY_VERSION}_Linux-64bit.deb"
          sudo dpkg -i /tmp/trivy.deb
          
          trivy --version

      - name: Report verification result
        if: always()
        run: |
          IMAGE="${{ steps.image.outputs.image }}"
          VERIFIED="${{ steps.verify-sbom.outputs.verified }}"
          
          if [ "$VERIFIED" = "true" ]; then
            echo "${{ matrix.chart }}: SBOM signature verified"
          else
            echo "${{ matrix.chart }}: SBOM is not signed or cannot be verified"
            exit 1
          fi

      - name: Check if SBOM matches image contents
        id: check-sbom
        if: steps.verify-sbom.outputs.verified == 'true'
        continue-on-error: true
        run: |
          IMAGE="${{ steps.image.outputs.image }}"
          SBOM_FILE="${{ steps.verify-sbom.outputs.sbom-file }}"
          echo "Checking if SBOM matches image contents for ${IMAGE}"

          # Generate fresh SBOM from image
          trivy image --format spdx-json ${IMAGE} > /tmp/generated-sbom.json 2>/dev/null

          # Extract SBOM from in-toto attestation (the signed/source SBOM)
          jq '.predicate' "${SBOM_FILE}" > /tmp/source-sbom.json

          # Normalize SBOM by:
          # 1. Removing dynamic fields (timestamps, UUIDs, content hashes, layer info)
          # 2. Recursively sorting all object keys for canonical form
          # 3. Using jq's built-in @json for deterministic output
          normalize_sbom() {
            jq '
              # Walk through entire structure and remove dynamic fields
              walk(
                if type == "object" then
                  del(
                    .creationInfo.created,
                    .documentNamespace,
                    .SPDXID,
                    .attributionTexts.LayerDigest,
                    .RepoDigest,
                    .RepoTag,
                    .name  # Container image names vary by reference (tag vs digest)
                  ) |
                  # Sort all keys alphabetically at this level
                  to_entries | sort_by(.key) | from_entries
                else . end
              )
            ' "$1" | jq -S . # Final sort to ensure canonical form
          }

          # Normalize both SBOMs
          echo "Normalizing generated SBOM..."
          normalize_sbom /tmp/generated-sbom.json > /tmp/generated-sbom-normalized.json
          echo "Normalizing source SBOM..."
          normalize_sbom /tmp/source-sbom.json > /tmp/source-sbom-normalized.json

          # Compare the normalized SBOMs using hash for robustness
          GENERATED_HASH=$(sha256sum /tmp/generated-sbom-normalized.json | awk '{print $1}')
          SOURCE_HASH=$(sha256sum /tmp/source-sbom-normalized.json | awk '{print $1}')

          echo "Generated SBOM hash: $GENERATED_HASH"
          echo "Source SBOM hash: $SOURCE_HASH"

          if [ "$GENERATED_HASH" = "$SOURCE_HASH" ]; then
            echo "✓ SBOM matches image contents (excluding dynamic fields)"
            echo "sbom-matches=true" >> $GITHUB_OUTPUT
          else
            echo "✗ SBOM does NOT match image contents"
            echo "Showing first differences (max 50 lines):"
            diff /tmp/generated-sbom-normalized.json /tmp/source-sbom-normalized.json | head -50 || true
            echo "sbom-matches=false" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: Scan SBOMs
        id: trivy-sbom-scan
        if: steps.verify-sbom.outputs.verified == 'true'
        continue-on-error: true
        run: |
          IMAGE="${{ steps.image.outputs.image }}"
          echo "Scanning SBOM of image: ${IMAGE}"
          trivy image --sbom-sources oci --format sarif --output trivy-results-${{ matrix.chart }}.sarif --severity CRITICAL,HIGH ${IMAGE}
          echo "Finished SBOM scan, results:"
          cat trivy-results-${{ matrix.chart }}.sarif

          # Check if SARIF file was created and has findings
          if [ -f "trivy-results-${{ matrix.chart }}.sarif" ]; then
            # Count vulnerabilities in SARIF
            VULN_COUNT=$(jq '.runs[0].results | length' trivy-results-${{ matrix.chart }}.sarif 2>/dev/null || echo 0)
            echo "Vulnerabilities found: $VULN_COUNT"
            if [ "$VULN_COUNT" -gt 0 ]; then
              exit 1
            fi
          fi

      - name: Upload results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v4
        if: steps.verify-sbom.outputs.verified == 'true'
        with:
          sarif_file: 'trivy-results-${{ matrix.chart }}.sarif'
          category: 'trivy-${{ matrix.chart }}'
      
      - name: Fail if vulnerabilities detected
        if: steps.trivy-sbom-scan.outcome == 'failure'
        run: |
          echo "CRITICAL or HIGH vulnerabilities found in ${{ matrix.chart }}"
          echo "Deployment blocked! Check the Security tab for details."
          exit 1
          